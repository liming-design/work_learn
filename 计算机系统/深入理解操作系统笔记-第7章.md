# 第7章
链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载(复制)到内存并执行。链接可以执行于编译时(compile time)，也就是在源代码被翻译成机器代码时;也可以执行于加载时(load time)，也就是在程序被加载器(load-er)加载到内存并执行时﹔甚至执行于运行时(run time)，也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器(linker)的程序自动执行的。

链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译(separate com-pilation)成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。
## 7.1 编译器驱动程序
code/link/main.c
```c
int sum(int *a,int n);
int array [2] = {1,2};
int main()
{
	int val = sum(array,2);
	return val;
}
```

code/link/sum.c
```c
int sum(int *a, int n)
{
	int i,s =0;
	for (i =0; i < n; i++)
	{
		s+=a[i];
	}
	return s;
}
```

大多数编译系统提供编译器驱动程序(compiler driver)，它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。比如，要用GNU编译系统构造示例程序,我们就要通过在shell中输入下列命令来调用GCC驱动程序:
`gcc -v -Og -o prog main.c sum.c`

![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220629183003541-234433743.png)

图7-2概括了驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为。(如果你想看看这些步骤，用-v选项来运行GCC。)
驱动程序首先运行C预处理器(cpp)，它将C的源程序main.c翻译成一个ASCII码的中间文件main.i:
`cpp [other arguments] main.c /tmp/main.i`

接下来，驱动程序运行C编译器(cc1)，它将main.i翻译成一个ASCII汇编语言文件main.s:
`cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s`
然后，驱动程序运行汇编器(as)，它将main.s翻译成一个可重定位目标文件( relo-catable object file)main.o:
`as [other arguments] -o /tmp/main.o /tmp/main.s`
驱动程序经过相同的过程生成sum.o。最后，它运行链接器程序ld，将main.o和sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件(executable ob-ject file)prog:
`ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o`

## 7.2 静态链接
为了构造可执行文件，链接器必须完成两个主要任务:
- 符号解析(symbol resolution)。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
- 重定位(relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目(relocation entry)的详细指令，不加甄别地执行这样的重定位。

## 7.3 目标文件
目标文件有三种形式:
- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

编译器和汇编器生成可重定位目标文件(包括共享目标文件)。链接器生成可执行目标文件。
目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。现代x86-64 Linux和Unix系统使用可执行可链接格式(Execut-able and Linkable Format，ELF)。尽管我们的讨论集中在ELF上，但是不管是哪种格式，基本的概念是相似的。

## 7.4 可重定位目标文件
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630115406066-591435681.png)
图7-3展示了一个典型的ELF可重定位目标文件的格式。ELF头(EL
header)以一个16字节的序列开始,这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF头的大小、目标文件的类型(如可重定位、可执行或者共享的)、机器类型(如 x86-64)、节头部表(section header table)的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目(entry)。
夹在ELF头和节头部表之间的都是节。一个典型的ELF可重定位目标文件包含下面几个节:

```
.text:已编译程序的机器代码。

.rodata:只读数据,比如printf语句中的格式串和开关语句的跳转表。

.data:已初始化的全局和静态C变量。局部C变量在运行时被保存在栈中，既不出现在.data节中，也不出现在.bss节中。

.bss:未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率:在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。

.symtab:一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过-g选项来编译一个程序，才能得到符号表信息。实际上， 每个可重定位目标文件在.symtab中都有一张符号表(除非程序员特意用STRIP命令去掉它)。然而，和编译器中的符号表不同，.symtab符号表不包含局部变量的条目。

.rel.text:一个.text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。

.rel.data:被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。

.debug:一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件。只有以-g选项调用编译器驱动程序时，才会得到这张表。

.line:原始C源程序中的行号和.text节中机器指令之间的映射。
只有以-g 选项调用编译器驱动程序时,才会得到这张表。

.strtab:一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串的序列。

```

## 7.5 符号和符号表
每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号:
- 由模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量。
- 由其他模块定义并被模块m引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量。
- 只被模块m定义和引用的局部符号。它们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。

认识到本地链接器符号和本地程序变量不同是很重要的。.symtab中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。

有趣的是，定义为带有C static属性的本地过程变量是不在栈中管理的。相反，编译器在.data或.bss中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。比如，假设在同一模块中的两个函数各自定义了一个静态局部变量x:

```c
int f()
{
	static int x=0;
	return x;
}
int g()
{
	static int x= 1;
	return x;
}
```

在这种情况中，编译器向汇编器输出两个不同名字的局部链接器符号。比如，它可以用x.1表示函数f中的定义，而用x.2表示函数g中的定义。
符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号。.symtab节中包含ELF符号表。这张符号表包含一个条目的数组。图7-4展示了每个条目的格式。
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630135456791-1003845694.png)
name是字符串表中的字节偏移，指向符号的以null结尾的字符串名字。value是符号的地址。对于可重定位的模块来说，value是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址。size是目标的大小(以字节为单位)。type通常要么是数据，要么是函数。符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目。所以这些目标的类型也有所不同。binding字段表示符号是本地的还是全局的。
每个符号都被分配到目标文件的某个节，由 section字段表示，该字段也是一个到节头部表的索引。有三个特殊的伪节(pseudosection)，它们在节头部表中是没有条目的:ABS代表不该被重定位的符号;UNDEF代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号;COMMON表示还未被分配位置的未初始化的数据目标。对于COMMON符号，value字段给出对齐要求，而size给出最小的大小。注意，只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。
COMMON和.bss的区别很细微。现代的GCC版本根据以下规则来将可重定位目标文件中的符号分配到COMMON和.bss中:
```
COMMON         未初始化的全局变量
.bss           未初始化的静态变量﹐以及初始化为0的全局或静态变量
```

GNU READELF程序是一个查看目标文件内容的很方便的工具。比如，下面是图7-1中示例程序的可重定位目标文件main.o的符号表中的最后三个条目。开始的8个条目没有显示出来,它们是链接器内部使用的局部符号。


![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630140417499-504974972.png)

在这个例子中，我们看到全局符号main定义的条目，它是一个位于.text节中偏移量为o(即value值)处的24字节函数。其后跟随着的是全局符号 array的定义，它是一个位于.data节中偏移量为0处的8字节目标。最后一个条目来自对外部符号sum的引用。READELF用一个整数索引来标识每个节。Ndx=1表示.text节，而Ndx=3示.data节。


## 7.6 符号解析

### 7.6.1 链接器如何解析多重定义的全局符号
链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的(只对定义该符号的模块可见)，有些是全局的(对其他模块也可见)。如果多个模块定义同名的全局符号，会发生什么呢?下面是Linux编译系统采用的方法。

在编译时，编译器向汇编器输出每个全局符号，或者是强(strong)或者是弱( weak),而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号,未初始化的全局变量是弱符号。
根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名:
- 规则1:不允许有多个同名的强符号。
- 规则2:如果有一个强符号和多个弱符号同名，那么选择强符号。
- 规则3:如果有多个弱符号同名，那么从这些弱符号中任意选择一个。
相同的全局变量在不同的模块中被定义并初始化链接器会报错。
如果在一个模块里x未被初始化，那么链接器将安静地选择在另一个模块中定义的强符号。
如果x不幸地在一个模块中定义为int，而在另一个模块中定义为double。
double类型是8个字节,而int类型是4个字节。x被赋值为double后会覆盖自己后面的4个字节。





### 7.6.2 与静态库连接
静态库概念被提出来，相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用C标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接:
`gcc main.c /usr/lib/libm.a /usr/lib/libc.a`
在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字(实际上，C编译器驱动程序总是传送libc.a给链接器，所以前面提到的对libc.a的引用是不必要的)。
在Linux系统中，静态库以一种称为存档(archive)的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀.a标识。


为了使我们对库的讨论更加形象具体，考虑图7-6中的两个向量例程。每个例程，定义在它自己的目标模块中，对两个输人向量进行一个向量操作，并把结果存放在一个输出向量中。每个例程有一个副作用，会记录它自己被调用的次数，每次被调用会把一个全局变量加1。(当我们在7.12节中解释位置无关代码的思想时会起作用。)


code/link/addvec.c
```c
int addcnt =0;
void addvec(int*x，int *y,int*z，int n)
{
	int i;
	addcnt++;
	for (i = 0; i <n; i++)
	z[i] = x[i] + y[i];
}

```

code/link/multvec.c
```c
int multcnt =0;
void multvec(int*x,int *y,int*z，int n)
{
	int i ;
	multcnt++;
	for (i =0; i < n; i++)
		z[i] = x[i] * y[i];
}
```

使用AR工具，创建这些函数的静态库：

```bash
gcc -c addvec.c multvec.c
ar rcs libvector.a addvec.o multvec.o
```

为了使用这个库，我们可以编写一个应用，比如下面的main2.
c，它调用addvec库例程。包含(或头)文件 vector.h定义了libvector.a中例程的函数原型。

```c
#include <stdio.h>
#include "vector.h"
int x[2] = {1，2];
int y[2] = {3，4};
int z[2];

int main(){
addvec(x, y，z，2);
printf("z=[%d %d]ln"，z[0]，z[1]);
return 0;
}
```

为了创建这个可执行文件，我们要编译和链接输入文件main2.o和 libvector.a:
```bash
gcc -c main2.c
gcc -static -o prog2c main2.o ./libvector.a

或者等价地使用:

gcc -c main2.c
gcc -static -o prog2c main2.o -L.-lvector

```

图7-8概括了链接器的行为。-static参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链接。-lvector参数是libvector.a的缩写，-L参数告诉链接器在当前目录下查找libvector.a。
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630112849740-1669104681.png)

当链接器运行时，它判定main2.o引用了 addvec.o定义的addvec符号，所以复制addvec.o到可执行文件。因为程序不引用任何由multvec.o定义的符号，所以链接器就不会复制这个模块到可执行文件。链接器还会复制libc.a中的 printf.o模块，以及许多C运行时系统中的其他模块。

### 7.6.3 链接器如何使用静态库来解析引用
在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。(驱动程序自动将命令行中所有的.c文件翻译为.o文件。)在这次扫描中，链接器维护一个可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件)，一个未解析的符号(即引用了但是尚未定义的符号)集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D均为空。
- 对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E，修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。
- 如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到U和D都不再发生变化。此时，任何不包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。
- 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。

不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。

## 7.7 重定位
一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义(即它的一个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道它的输人目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成:

- 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。
- 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目(relocation entry)的数据结构，我们接下来将会描述这种数据结构。

### 7.7.1 重定位条目
当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。
图7-9展示了ELF重定位条目的格式。offset是需要被修改的引用的节偏移。symbol标识被修改引用应该指向的符号。type告知链接器如何修改新的引用。addend是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630151721397-1561891630.png)

### 7.7.2 重定位符号引用
图7-10展示了链接器的重定位算法的伪代码。第1行和第⒉2行在每个节s 以及与每个节相关联的重定位条目r上迭代执行。为了使描述具体化，假设每个节s是一个字节数组，每个重定位条目r是一个类型为Elf64_Rela的结构，如图7-9中的定义。另外还假设当算法运行时，链接器已经为每个节(用ADDR(s)表示)和每个符号都选择了运行时地址(用ADDR(r.symbol)表示)。第3行计算的是需要被重定位的4字节引用的数组s中的地址。如果这个引用使用的是PC相对寻址，那么它就用第5~9行来重定位。如果该引用使用的是绝对寻址，它就通过第11～13行来重定位。
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630165523111-1213426775.png)
让我们来看看链接器如何用这个算法来重定位图7-1示例程序中的引用。图7-11给出了(用objdump-dx main.o产生的)GNU OBJDUMP 工具产生的main.o的反汇编代码。


![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630165737573-2125856052.png)
main函数引用了两个全局符号: array和 sum。为每个引用，汇编器产生一个重定位条目，显示在引用的后面一行上。这些重定位条目告诉链接器对 sum的引用要使用32位PC相对地址进行重定位，而对array 的引用要使用32位绝对地址进行重定位。
1.重定位 PC相对引用
就是根据7-9那个结构体对每一个节（s）中的重定位条目（r）进行图7-10的定位运算，使得运行时能跳到正确的位置。
书中有详细介绍。
2.重定位绝对引用
与PC相对引用的过程类似。

## 7.8 可执行目标文件
我们已经看到链接器如何将多个目标文件合并成一个可执行目标文件。我们的示例C程序，开始时是一组ASCII文本文件，现在已经被转化为一个二进制文件，且这个二进制文件包含加载程序到内存并运行它所需的所有信息。图7-13概括了一个典型的ELF可执行文件中的各类信息。

![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220630171824028-1193420162.png)

## 7.9 加载可执行目标文件
当加载器运行时，它创建类似于图7-15所示的内存映像。在程序头部表的引导下，加载器将可执行文件的片(chunk)复制到代码段和数据段。接下来加载器跳转到程序的人口点，也就是_start函数的地址。这个函数是在系统目标文件ctrl.o中定义的，对所有的C程序都是一样的。\_start函数调用系统启动函数\_ \_libc_start_main，该函数定义在libc.so中。它初始化执行环境，调用用户层的main函数，处理main函数的返回值,并且在需要的时候把控制返回给内核。

![image](https://img2022.cnblogs.com/blog/1865959/202207/1865959-20220704153733167-620465210.png)

## 7.10 动态链接共享库
共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器(dynamic linker)的程序来执行的。共享库也称为共享目标(shared object)，在 Linux系统中通常用.so后缀来表示。微软的操作系统大量地使用了共享库，它们称为DLL(动态链接库)。

`gcc -shared -fpic -o libvector.so addvec.c multvec.c`

-fpic选项指示编译器生成与位置无关的代码(下一节将详细讨论这个问题)。
-shared选项指示链接器创建一个共享的目标文件。一旦创建了这个库，随后就要将它链接到图7-7的示例程序中:

`linux> gcc -o prog2l main2.c ./libvector.so`

![image](https://img2022.cnblogs.com/blog/1865959/202207/1865959-20220704152901886-1205280508.png)

这样就创建了一个可执行目标文件 prog2l，而此文件的形式使得它在运行时可以和libvector.so链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。认识到这一点是很重要的：此时，没有任何 libvector.so的代码和数据节真的被复制到可执行文件 prog2l中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so中代码和数据的引用。

## 7.11 从应用程序中加载和链接共享库
到目前为止，我们已经讨论了在应用程序被加载后执行前时，
动态链接器加载和链接共享库的情景。然而，应用程序还可能在它运行时要求动态链接器加载和链接某个共享库,而无需在编译时将那些库链接到应用中。

Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。
```c
#include <dlfcn.h>
void *dlopen(const char *filename，int flag);
void *dlsym(void *handle，char *symbol);
int dlclose (void *handle);
const char *dlerror(void);
```
- dlopen 函数加载和链接共享库filename。用已用带 RTLD_GLOBAL选项打开了的库解析filename 中的外部符号。如果当前可执行文件是带-rdynamic选项编译的，那么对符号解析而言，它的全局符号也是可用的。flag参数必须要么包括RTLD_NOw，该标志告诉链接器立即解析对外部符号的引用，要么包括RTLD_LAZY标志，该标志指示链接器推迟符号解析直到执行来自库中的代码。这两个值中的任意一个都可以和RTLDGLOBAL标志取或。
- dlsym函数的输入是一个指向前面已经打开了的共享库的句柄和一个symbol名字，如果该符号存在,就返回符号的地址,否则返回NULL。
- 如果没有其他共享库还在使用这个共享库，dlclose 函数就卸载该共享库。
- dlerror函数返回一个字符串，它描述的是调用dlopen、dlsym或者dlclose函数时发生的最近的错误,如果没有错误发生,就返回NULL。

下面的程序展示了如何利用这个接口动态链接我们的 libvector.so共享库，然后调用它的addvec例程。要编译这个程序，我们将以下面的方式调用GCC:
`gcc -rdynamic -o prog2r dll.c -ldl`

```c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>
int x[2] = {1,2};
int y[2] = {3,4};
int z[2];
int main()
{
    void *handle;
    void (*addvec)(int *,int *,int*, int);char *error ;
    /* Dynamically load the shared library containing addvec()*/
    handle = dlopen("./libvector.so",RTLD_LAZY);
    if (!handle) {
        fprintf(stderr,"%s\n", dlerror());
        exit(1);
    }
    /* Get a pointer to the addvec() function we just loaded */
    addvec = dlsym(handle,"addvec" );
    if ((error = dlerror())!=NULL) {
        fprintf(stderr,"%s\n" ,error);
    exit(1);
    }
    /* Now we can call addvec() just like any other function*/
    addvec(x, y,z,2);
    printf("z =[%d %d]\n",z[0],z[1]);

    /*Unload the shared library */
    if (dlclose(handle) < 0){
        fprintf(stderr,"%s\n" , dlerror());
        exit(1);
    }
    return 0;
}
```

## 7.12 位置无关代码
现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。(当然，每个进程仍然会有它自己的读/写数据块。)
可以加载而无需重定位的代码称为位置无关代码(Position-Independent Code，PIC)。用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项。

1.PCI数据引用
编译器通过运用以下这个有趣的事实来生成对全局变量的PIC
引用:无论我们在内存中的何处加载一个目标模块(包括共享目标模块)，数据段与代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。
图7-18展示了示例libvector.so共享模块的GOT。addvec例程通过GOT\[3]间接地加载全局变量addcnt的地址，然后把 addcnt在内存中加1。这里的关键思想是对GOT\[3]的 PC相对引用中的偏移量是一个运行时常量。
![](Pasted%20image%2020220705163921.png)

2.PCI函数调用
假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是 PIC，因为它需要链接器修改调用模块的代码段，GNU编译系统使用了一种很有趣的技术来解决这个问题，称为延迟绑定(lazy binding)，将过程地址的绑定推迟到第一次调用该过程时。
延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是:GOT和过程链接表(Procedure Linkage Table，PLT)。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和 PLT。GOT是数据段的一部分，而PLT是代码段的一部分。
## 7.13 库打桩机制
Linux链接器支持一个很强大的技术，称为库打桩(library interpositioning)，它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。



## 7.14处理目标文件的工具
- AR:创建静态库,插入、删除、列出和提取成员。STRINGS:列出一个目标文件中所有可打印的字符串。STRIP:从目标文件中删除符号表信息。
- NM:列出一个目标文件的符号表中定义的符号。SIZE:列出目标文件中节的名字和大小。
- READELF:显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和 NM的功能。
- OBJDUMP:所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编.text节中的二进制指令。

Linux系统为操作共享库还提供了LDD程序:
- LDD:列出一个可执行文件在运行时所需要的共享库。




