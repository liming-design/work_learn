# 第2章 信息的表示和处理
## 2.1 信息存储
非负整数是2的整数幂时快速写成十六进制

### 字长的概念
每台计算机都有一个字长( word size)，指明指针数据的标称大小(nominal size)。因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就是说，对于一个字长为w位的机器而言，虚拟地址的范围为0~ $2^w-1$ ,程序最多访问$2^w$个字节。
大多数64位机器也可以运行为32位机器编译的程序，这是一种向后兼容。

C语言支持整数和浮点数的多种数据格式。图2-3展示了为C语言各种数据类型分配的字节数。
![在这里插入图片描述](https://img-blog.csdnimg.cn/40d2214a40a44b40a99e69ba675ce353.png)

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型int32_t和int64 t，它们分别为4个字节和8个字节。使用确定大小的整数类型是程序员准确控制数据表示的最佳途径。

### 小端、大端法
最低有效字节在最前面的方式，称为小端法(little endian)。
最高有效字节在最前面的方式，称为大端法(big endian)。

假设变量×的类型为int，位于地址0x100处，它的十六进制值为0x01234567。地址范围0x100～0x103的字节顺序依赖于机器的类型:
![在这里插入图片描述](https://img-blog.csdnimg.cn/3246a53fcd9a4fa9a66e13d64d37e1a1.png)
注意，在字0x01234567中，高位字节的十六进制值为0x01，而低位字节值为0x67。

以前的印象中，==大端更符合人的阅读习惯，小端更利于计算机的读取==，但书中仅仅提到了不同的机器使用不同的规范，小端与平常阅读习惯相反，没有提到效率问题。

在几种不同的机器上显示编码规则，使用了如下代码进行测试：

```c
#include <stdio.h>

typedef unsigned char *byte_pointer;

void show_bytes(byte_pointer start, size_t len){
    size_t i;
    for (i = 0; i < len; i++)
    printf("%.2x" , start[i]);
    printf("\n");
}

void show_int(int x){
    show_bytes( (byte_pointer)&x,sizeof(int));
}

void show_float(float x){
    show_bytes( (byte_pointer) &x, sizeof(float));
}

void show_pointer(void *x){
    show_bytes((byte_pointer) &x,sizeof(void *));
}

void test_show_bytes(int val){
    int ival = val;
    float fval =(float) ival;
    int *pval = &ival;
    show_int(ival);
    show_float(fval);
    show_pointer(pval);
}

int main(){
    test_show_bytes(12345);
}
```
过程`show_int`、`show_float`和`show _pointer`展示了如何使用程序`show_bytes`来分别输出类型为`int`、`float`和 `void *`的C程序对象的字节表示。可以观察到它们仅仅传递给show bytes一个指向它们参数x的指针`&x`，且这个指针被强制类型转换为`unsigned chdr * `。这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字节序列，而不是指向一个原始数据类型的对象。然后，这个指针会被看成是对象使用的最低字节地址。

在几种不同的机器上运行上述代码，得到如图2-6所示的结果。我们使用了以下几种机器:
- Linux 32:运行Linux的Intel IA32处理器。
- Windows:运行Windows的Intel IA32处理器。
- Sun:运行Solaris的 Sun Microsystems SPARC处理器。(这些机器现在由Oracle生产
- Linux 64:运行Linux的Intel x86-64处理器。
![在这里插入图片描述](https://img-blog.csdnimg.cn/b06bae764e904d0c8f1b263c6a25a61e.png)

参数12345的十六进制表示为0x00003039。对于int类型的数据，除了字节顺序以外，我们在所有机器上都得到相同的结果。




### 位级运算
|  或
& 与
~ 取反
^ 异或
这些运算能运用到任何“整型”的数据类型上，包括图2-3所示内容。以下是一些对char数据类型表达式求值的例子:
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220622110908461-1678343041.png)

### 逻辑运算
|| 或
&& 与
! 非

逻辑运算符&&和Ⅱ与它们对应的位级运算&和|之间的区别是：如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，例如，表达式`a&&5/a`将不会造成被零除，而表达式`p&&*p++`也不会导致间接引用空指针。


### 移位
#### 算术移位
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220622104441085-1583775578.png)
- ==左移(<<)N位的本质是乘以2的N次方==
- ==右移(>>)N位的本质是除以2的N次方==


#### 逻辑移位
逻辑移位将操作数视为无符号数。
移位规则:逻辑左移时，高位移丢，低位添0﹔
逻辑右移时，低位移丢，高位添0。
注意:逻辑移位不管是左移还是右移，都添0。

应用场景举例1：原码一位乘法运算
在进行乘法运算过程中，乘数（保存在MQ中）的最低位与被乘数（保存在X中）运算后的结果会更新到ACC当中，之后（ACC和MQ）会执行逻辑右移，MQ低位丢弃，ACC逻辑右移后高位补0，MQ中新的低位继续与被乘数运算，得到的结果累加到ACC中，重复以上步骤，得到最终的结果（ACC和MQ拼接起来）


与C相比，Java对于如何进行右移有明确的定义。表达是x>>k会将x算术右移k个位置,而x>>>k会对x做逻辑右移。


## 2.2 整数表示
源码、补码、反码

练习题2.25考虑下列代码，这段代码试图计算数组a中所有元素的和，其中元素的数量由参数length给出。
```
/* WARNING:This is buggy code*/
float sum_elements(float a[],unsigned length) {
	int i ;
	float result = 0;
	for (i = 0; i <= length-1; i++)
		result += a[i];
	return result;
}
```
当参数length 等于0时，运行这段代码应该返回0.0。但实际上，运行时会遇到一个内存错误。
因为参数length是无符号的，计算0-1将使用无符号运算，这等价于模数加法。结果得到UMax。≤比较同样使用无符号数比较，而因为任何数都是小于或者等于UMaz 的，所以这个比较总是为真！因此，代码将试图访问数组a的非法元素。
有两种方法可以改正这段代码，其一是将length声明为int类型，其二是将 for循环的测试条件改为i<length。

## 2.3 整数运算
无符号加法
补码加法
补码乘法
## 2.4 浮点数
IEEE浮点表示
舍入、溢出

以上二进制运算感觉有些绕，看不进去，想试试有实际需求的时候再回过来看。

源码：一个数最原始的二进制数
反码：正数的反码= 原码，负数的反码 = 符号位不变,其他位取反
补码：正数的补码 = 反码=原码，负数的补码 = 反码 +1

计算机中存的是一个数的补码