# 程序的机器级表示
本章会近距离地观察机器代码，以及人类可读的表示——汇编代码
虽然高级语言工作效率较高，也很可靠，但能够阅读和理解汇编代码仍是一项很重要的技能。可以让程序更高效。
## 3.1 历史观点
Intel处理器系列俗称x86，经历了一个长期的、不断进化的发展过程。

## 3.2程序编码
### 3.2.1 机器级代码
对于机器级编程来说,其中两种抽象尤为重要。
第一种是由**指令集体系结构或指令集架构(Instruction Set Architecture，ISA)** 来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。

第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来，这会在第9章中讲到

在整个编译过程中，编译器会完成大部分的工作，将把用C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。

x86-64的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的:
- 程序计数器(通常称为“PC”，在 x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址。
- 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。
- 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和 while语句。
- 一组向量寄存器可以存放一个或多个整数或浮点数值。

程序内存包含:
程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块(比如说用malloc库函数分配的)。

操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。

### 3.2.2 代码示例
假设我们写了一个C语言代码文件mstore.c，包含如下的函数定义:
```c
long mult2(long，long);

void multstore(long x,long y，long *dest) {
long t = mult2(x，y);
*dest = t;
}
```
在命令行上使用“-s”选项，就能看到C语言编译器产生的汇编代码:`gcc -Og -s mstore.c`

这会使GCC运行编译器，产生一个汇编文件mstore.s，但是不做其他进一步的工作。(通常情况下，它还会继续调用汇编器产生目标代码文件)。
汇编代码文件包含各种声明,包括下面几行:
```c
multstore:
	pushq    %rbx
	movq     %rdx，%rbx
	call     mult2
	movq     %rax,，(%rbx)
	popq     %rbx
	ret
```
上面代码中每个缩进去的行都对应于一条机器指令。比如，pushq指令表示应该将寄存器%rbx的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。
如果我们使用`-c`命令行选项，GCC会编译并汇编该代码:
`gcc -Og -c mstore.c`

这就会产生目标代码文件 mstore.o，它是二进制格式的，所以无法直接查看。1368字节的文件mstore.o中有一段14字节的序列，它的十六进制表示为:
`53 48 89 d3 e8 oo oo oo o0 48 89 03 5b c3`

这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。

```
旁注：如何展示程序的字节表示
要展示程序(比如说mstore)的二进制目标代码，我们用反汇编器(后面会讲到)确定该过程的代码长度是14字节。然后，在文件mstore.o上运行GNU调试工具GDB,输入命令:
`(gdb) x/14xb multstore`
这条命令告诉GDB显示(简写为‘x')从函数multstore所处地址开始的14个十六进制格式表示(也简写为‘x')的字节(简写为‘b')。
```

## 3.3 数据格式
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220623143953962-336205733.png)
如图所示大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种:movb(传送字节)、movw(传送字)、movl(传送双字)和 movq(传送四字)。后缀‘l'用来表示双字，因为32位数被看成是“长字(longword)”。注意，汇编代码也使用后缀‘l'来表示4字节整数和8字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。
## 3.4 访问信息
```
一个x86-64位的中央处理单元（CPU）包含一组16个存储64位值得通用目的存储器，这些寄存器用来存储整数数据和指针。
它们的名字都已%r开头，不过后面还跟着一些不同得命名规则的名字，这是由于指令集历史演化造成的。
最初的8086中有8个16位的寄存器，即从%ax到%sp。
每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。
扩展到IA32架构，这些寄存器也扩展成32位寄存器，标号从%eax到%esp。
扩展到x86-64后，原来的8个寄存器扩展成64位，标号从%rax到%rsp。
除此之外，还增加了8个新的寄存器，它们的标号是按照新的命名规则制定的：从%r8到%r15。
```

![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220624111355896-973002231.png)
在后面的章节中，我们会展现很多指令，复制和生成1字节、2字节、4字节和8字节值。当这些指令以寄存器作为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则:生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。后面这条规则是作为从IA32到x86-64的扩展的一部分而采用的。

栈指针%rsp，用来指明运行时栈的结束位置。

### 3.4.1 操作数指令符
大多数指令有一个或多个操作数(operand),各种不同的操作数的可能性被分为三种类型。
- 第一种类型是立即数(immediate),用来表示常数值。在ATT格式的汇编代码中，立即数的书写方式是‘$'后面跟一个用标准C表示法表示的整数。
- 第二种类型是寄存器( register) ,它表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数﹐这些字节数分别对应于8位、16位、32位或64位。我们用符号 r$_a$   来表示任意寄存器a，用引用R\[r$_a$]来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符作为索引。
- 第三类操作数是内存引用，它会根据计算出来的地址(通常称为有效地址)访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号$M_b$\[Addr]表示对存储在内存中从地址Addr开始的b个字节值的引用。为了简便，我们通常省去下标b。
如图3-3所示，有多种不同的寻址模式，允许不同形式的内存引用。表中底部用语法Imm($r_b$，$r_i$，s)表示的是最常用的形式。这样的引用有四个组成部分:一个立即数偏移Imm，一个==基址寄存器$r_b$==，一个==变址寄存器$r_i$==，和一个比例因子s，这里s必须是1、2、4或者8。基址和变址寄存器都必须是64位寄存器。有效地址被计算为 Imm+R\[$r_b$]+R\[$r_i$]·s。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。正如我们将看到的，当引用数组和结构元素时，比较复杂的寻址模式是很有用的。
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220624113634079-258793619.png)


### 3.4.2数据传送指令
图3-4列出的是最简单形式的数据传送指令——MOV类。这些指令把数据从源位置复制到目的位置，不做任何变化。MOV类由四条指令组成: movb、movw、movl和movq。这些指令都执行同样的操作﹔主要区别在于它们操作的数据大小不同:分别是1、2、4和8字节。
![image](https://img2022.cnblogs.com/blog/1865959/202206/1865959-20220624105820329-182551535.png)
大多数情况中，MOV指令只会更新目的操作数指定的那些奇仔益子卫蚁内仔 。成一个例外龙movl指令以寄存器作为目的时，它会把该寄存器的高位4字节设置为0。造成这个例外的原因是x86-64采用的惯例，即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0。

### 3.4.3 数据传送示例

### 3.4.4压入和弹出栈数据

## 3.5 算术和逻辑操作
## 3.6 控制

## 3.7 控制

## 3.8 数组分配和访问

## 3.9 异质的数据结构

## 第7章 链接

