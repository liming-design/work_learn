## 第一章  计算机系统漫游
### hello word 程序的生命周期
#### 编译hello程序
![在这里插入图片描述](https://img-blog.csdnimg.cn/56cf106663044898b83ef30b814dc0ac.png)
- 预处理阶段：预处理器(cpp)根据以字符#开头的命令，修改原始的C程序。比如hello.c中第1行的#include <stdio.h>命令告诉预处理器读取系统头文件stdio.h的内容，并把它直接插入程序文本中。结果就得到了另一个C程序，通常是以.i作为文件扩展名。
- 编译阶段：编译器(ccl)将文本文件 hello.i翻译成文本文件 hello.s，它包含一个汇编语言程序。该程序包含函数main 的定义。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。
- 汇编阶段：接下来，汇编器(as)将hello.s翻译成机器语言指令，把这些指令打包成一种叫做可重定位目标程序(relocatable object program)的格式，并将结果保存在目标文件 hello.o中。hello.o文件是一个二进制文件，它包含的17个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。
- 链接阶段：请注意，hello程序调用了printf函数，它是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器(ld)就负责处理这种合并。结果就得到hello文件，它是一个可执行目标文件(或者简称为可执行文件)，可以被加载到内存中，由系统执行。


#### 运行hello程序
初始时，shell程序执行它的指令，等待我们输入一个命令。当我们在键盘上输人字符串“./hello”后，shell程序将字符逐一读人寄存器，再把它存放到内存中，如图1-5所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/df571b056e174975805334ac31b83e41.png)

当我们在键盘上敲回车键时，shell程序就知道我们已经结束了命令的输人。然后shell执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串“hello,world\n”。
![在这里插入图片描述](https://img-blog.csdnimg.cn/17d7c2936c004902a88ae17b3f2d08ba.png)

一旦目标文件 hello中的代码和数据被加载到主存，处理器就开始执行hello程序的 main程序中的机器语言指令。这些指令将“hello, world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如图1-7所示。
![在这里插入图片描述](https://img-blog.csdnimg.cn/3367aca622074331b1364f8d77e92ab1.png)
### 高速缓存
以上示例揭示了一个重要问题，系统花费了大量时间把信息从一个地方挪到另一个地方，于是需要高速缓存。
![在这里插入图片描述](https://img-blog.csdnimg.cn/6ff1522d9a9f40e1ab2f9b1a25de4df1.png)
存储设备的层次结构：
![在这里插入图片描述](https://img-blog.csdnimg.cn/8e3329b6a9474309b68cb577e69e3555.png)


存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。

### 进程
进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。

### 线程
尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。

### 虚拟内存
虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。图1-13所示的是Linux进程的虚拟地址空间(其他Unix系统的设计也与此类似)。在Linux中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/af84e2cc465c4323b4e1bcddcc7559d1.png)

### 文件
文件就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输人输出都是通过使用一小组称为Unix I/O 的系统函数调用读写文件来实现的。

### Amdahl 定律
该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。
若系统执行某应用程序需要时间为Told。假设系统某部分所需执行时间与该时间的比例为α，而该部分性能提升比例为k。即该部分初始所需时间为αTold，现在所需时间为(α Told )/k。因此,总的执行时间应为
![在这里插入图片描述](https://img-blog.csdnimg.cn/5eb98cc25e144c51a6dd6cab80422102.png)