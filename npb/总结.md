## 动态库 和 静态库
### 静态库
静态库即静态链接库，静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。


![image](https://img2022.cnblogs.com/blog/1865959/202207/1865959-20220711181433239-506269300.png)


### 动态库
动态库在编译时会存储指向动态库的引用，在运行时动态库才会被动态加载进来。

![image](https://img2022.cnblogs.com/blog/1865959/202207/1865959-20220711181317108-726202108.png)



上述是在应用程序被加载后执行前时，动态链接器加载和链按共享库的情景。然而，应用程序还可能在它运行时要求动态链接器加载和链接某个共享库,而无需在编译时将那些库链接到应用中。

Linux系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。
```c
#include <dlfcn.h>
void *dlopen(const char *filename，int flag);
void *dlsym(void *handle，char *symbol);
int dlclose (void *handle);
const char *dlerror(void);
```

以上为静态、动态库区别，没有理解清晰。

## Linux 和 Windows 生成的汇编指令一样吗
- 汇编语言是用人类看得懂的语言来描述指令集。
- 指令集决定了处理器的架构。
- 处理器架构就是处理器的硬件架构，称为微架构。是一堆硬件电路，去实现指令集所规定的操作运算。

Linux下采用的是AT＆T的汇编语法格式，Windows下面采用的是Intel汇编语法格式。二者的主要区别在于：
```
1.指令操作数的赋值方向是不同的 

   Intel：第一个是目的操作数，第二个是源操作数 

   AT＆T：第一个是源操作数，第二个是目的操作数

2.指令前缀 

   AT＆T：寄存器前边要加上％，立即数前要加上$ 

   Intel：没有这方面的要求

3.内存单元操作数 

   Intel：基地址使用［］ 

   AT&T：  基地址使用（） 

  比如：intel中  mov  ax,[bx] 

              AT&T中 movl (%eax),%ebx

4.操作码的后缀 

     AT&T中操作码后面有一个后缀字母:“l” 32位,“w” 16位,“b” 8位 

     Intel却使用了在操作数前面加dword ptr, word ptr, byte ptr的格式 

   例如:mov al,bl (Intel) 

             movb %bl %al (AT&T)

5.AT＆T中跳转指令标号后的后缀 表示跳转方向，“f”表示向前，“b”表示向后
```

## 大端小端
大多数Intel兼容机都只用小端模式。另一方面，IBM 和Oracle(从其2010年收购Sun Microsystems开始)的大多数机器则是按大端模式操作。注意我们说的是“大多数”。这些规则并没有严格按照企业界限来划分。比如，IBM和Oracle制造的个人计算机使用的是Intel兼容的处理器，因此使用小端法。许多比较新的微处理器是双端法( bi-endian),也就是说可以把它们配置成作为大端或者小端的机器运行。然而，实际情况是：一旦选择了特定操作系统，那么字节顺序也就固定下来。比如，用于许多移动电话的ARM微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统-—Android(来自Google)和IOS(来自Apple)——却只能运行于小端模式。
